from Crypto.Util.number import long_to_bytes
from fractions import Fraction

e = 61328576519007506774078892825545478875986136804870469236278271522744081253277985417577858742844865214185821957908900957816820934980600445886540227620575296652676666320031879828280507492712454050390760887075277034967362140324373847525493193322189285485695612954840780257289202593457047272112416401210246458299
n = 125853707334438541905595213421681870029885358740979349794206321726116696432716882897309737438036626933278288621383732625824271347387770836628649352977355055556895365423398129271147828379894356440683117835679441797794374754715943361174773003473344543388439664213844242211059144970022925071470597141712484296697
c = 55912920599700126404697819962382691394444906312556211456170562193292384723738950272597999266469251858870085306674336192614377459772719597843340383270106186300389503554660949465597310990657710232263052413584908258640374362916953548842006902171085433839206554258256118188099501057172373254582164496701918512780

def fracCalculator(list_linear):
    calculator = Fraction(0,1)
    for i in range(len(list_linear)-1,-1,-1):
        calculator = Fraction(1,calculator + list_linear[i])
    return (calculator.numerator,calculator.denominator)
    
def Wiener_attack(e,n): 
    # image is Wiener , Wiener attack can solve RSA d too small
    # if e,n small; u can use wolframalpha.com 
    # else use this code for e,n big
    linearFraction = []
    while e > 0 :
        linearFraction.append(n//e)
        n,e = e, n % e
    return linearFraction

linearFraction = Wiener_attack(e,n)
for i in range(len(linearFraction)):
    k,d = fracCalculator(linearFraction[:i+1])
    try:
        print(long_to_bytes(pow(c,d,n)).decode())
    except:
        continue

